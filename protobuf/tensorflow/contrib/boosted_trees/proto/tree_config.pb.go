// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/tensorflow/contrib/boosted_trees/proto/tree_config.proto

/*
	Package tensorflow_boosted_trees_trees is a generated protocol buffer package.

	It is generated from these files:
		protobuf/tensorflow/contrib/boosted_trees/proto/tree_config.proto

	It has these top-level messages:
		TreeNode
		TreeNodeMetadata
		Leaf
		Vector
		SparseVector
		DenseFloatBinarySplit
		SparseFloatBinarySplitDefaultLeft
		SparseFloatBinarySplitDefaultRight
		CategoricalIdBinarySplit
		CategoricalIdSetMembershipBinarySplit
		DecisionTreeConfig
		DecisionTreeMetadata
		GrowingMetadata
		DecisionTreeEnsembleConfig
*/
package tensorflow_boosted_trees_trees

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import fmt "fmt"
import strings "strings"
import reflect "reflect"

import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TreeNode describes a node in a tree.
type TreeNode struct {
	// Types that are valid to be assigned to Node:
	//	*TreeNode_Leaf
	//	*TreeNode_DenseFloatBinarySplit
	//	*TreeNode_SparseFloatBinarySplitDefaultLeft
	//	*TreeNode_SparseFloatBinarySplitDefaultRight
	//	*TreeNode_CategoricalIdBinarySplit
	//	*TreeNode_CategoricalIdSetMembershipBinarySplit
	Node         isTreeNode_Node   `protobuf_oneof:"node"`
	NodeMetadata *TreeNodeMetadata `protobuf:"bytes,777,opt,name=node_metadata,json=nodeMetadata" json:"node_metadata,omitempty"`
}

func (m *TreeNode) Reset()                    { *m = TreeNode{} }
func (*TreeNode) ProtoMessage()               {}
func (*TreeNode) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{0} }

type isTreeNode_Node interface {
	isTreeNode_Node()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TreeNode_Leaf struct {
	Leaf *Leaf `protobuf:"bytes,1,opt,name=leaf,oneof"`
}
type TreeNode_DenseFloatBinarySplit struct {
	DenseFloatBinarySplit *DenseFloatBinarySplit `protobuf:"bytes,2,opt,name=dense_float_binary_split,json=denseFloatBinarySplit,oneof"`
}
type TreeNode_SparseFloatBinarySplitDefaultLeft struct {
	SparseFloatBinarySplitDefaultLeft *SparseFloatBinarySplitDefaultLeft `protobuf:"bytes,3,opt,name=sparse_float_binary_split_default_left,json=sparseFloatBinarySplitDefaultLeft,oneof"`
}
type TreeNode_SparseFloatBinarySplitDefaultRight struct {
	SparseFloatBinarySplitDefaultRight *SparseFloatBinarySplitDefaultRight `protobuf:"bytes,4,opt,name=sparse_float_binary_split_default_right,json=sparseFloatBinarySplitDefaultRight,oneof"`
}
type TreeNode_CategoricalIdBinarySplit struct {
	CategoricalIdBinarySplit *CategoricalIdBinarySplit `protobuf:"bytes,5,opt,name=categorical_id_binary_split,json=categoricalIdBinarySplit,oneof"`
}
type TreeNode_CategoricalIdSetMembershipBinarySplit struct {
	CategoricalIdSetMembershipBinarySplit *CategoricalIdSetMembershipBinarySplit `protobuf:"bytes,6,opt,name=categorical_id_set_membership_binary_split,json=categoricalIdSetMembershipBinarySplit,oneof"`
}

func (*TreeNode_Leaf) isTreeNode_Node()                                  {}
func (*TreeNode_DenseFloatBinarySplit) isTreeNode_Node()                 {}
func (*TreeNode_SparseFloatBinarySplitDefaultLeft) isTreeNode_Node()     {}
func (*TreeNode_SparseFloatBinarySplitDefaultRight) isTreeNode_Node()    {}
func (*TreeNode_CategoricalIdBinarySplit) isTreeNode_Node()              {}
func (*TreeNode_CategoricalIdSetMembershipBinarySplit) isTreeNode_Node() {}

func (m *TreeNode) GetNode() isTreeNode_Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *TreeNode) GetLeaf() *Leaf {
	if x, ok := m.GetNode().(*TreeNode_Leaf); ok {
		return x.Leaf
	}
	return nil
}

func (m *TreeNode) GetDenseFloatBinarySplit() *DenseFloatBinarySplit {
	if x, ok := m.GetNode().(*TreeNode_DenseFloatBinarySplit); ok {
		return x.DenseFloatBinarySplit
	}
	return nil
}

func (m *TreeNode) GetSparseFloatBinarySplitDefaultLeft() *SparseFloatBinarySplitDefaultLeft {
	if x, ok := m.GetNode().(*TreeNode_SparseFloatBinarySplitDefaultLeft); ok {
		return x.SparseFloatBinarySplitDefaultLeft
	}
	return nil
}

func (m *TreeNode) GetSparseFloatBinarySplitDefaultRight() *SparseFloatBinarySplitDefaultRight {
	if x, ok := m.GetNode().(*TreeNode_SparseFloatBinarySplitDefaultRight); ok {
		return x.SparseFloatBinarySplitDefaultRight
	}
	return nil
}

func (m *TreeNode) GetCategoricalIdBinarySplit() *CategoricalIdBinarySplit {
	if x, ok := m.GetNode().(*TreeNode_CategoricalIdBinarySplit); ok {
		return x.CategoricalIdBinarySplit
	}
	return nil
}

func (m *TreeNode) GetCategoricalIdSetMembershipBinarySplit() *CategoricalIdSetMembershipBinarySplit {
	if x, ok := m.GetNode().(*TreeNode_CategoricalIdSetMembershipBinarySplit); ok {
		return x.CategoricalIdSetMembershipBinarySplit
	}
	return nil
}

func (m *TreeNode) GetNodeMetadata() *TreeNodeMetadata {
	if m != nil {
		return m.NodeMetadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TreeNode) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TreeNode_OneofMarshaler, _TreeNode_OneofUnmarshaler, _TreeNode_OneofSizer, []interface{}{
		(*TreeNode_Leaf)(nil),
		(*TreeNode_DenseFloatBinarySplit)(nil),
		(*TreeNode_SparseFloatBinarySplitDefaultLeft)(nil),
		(*TreeNode_SparseFloatBinarySplitDefaultRight)(nil),
		(*TreeNode_CategoricalIdBinarySplit)(nil),
		(*TreeNode_CategoricalIdSetMembershipBinarySplit)(nil),
	}
}

func _TreeNode_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TreeNode)
	// node
	switch x := m.Node.(type) {
	case *TreeNode_Leaf:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Leaf); err != nil {
			return err
		}
	case *TreeNode_DenseFloatBinarySplit:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DenseFloatBinarySplit); err != nil {
			return err
		}
	case *TreeNode_SparseFloatBinarySplitDefaultLeft:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseFloatBinarySplitDefaultLeft); err != nil {
			return err
		}
	case *TreeNode_SparseFloatBinarySplitDefaultRight:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseFloatBinarySplitDefaultRight); err != nil {
			return err
		}
	case *TreeNode_CategoricalIdBinarySplit:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CategoricalIdBinarySplit); err != nil {
			return err
		}
	case *TreeNode_CategoricalIdSetMembershipBinarySplit:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CategoricalIdSetMembershipBinarySplit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TreeNode.Node has unexpected type %T", x)
	}
	return nil
}

func _TreeNode_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TreeNode)
	switch tag {
	case 1: // node.leaf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Leaf)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_Leaf{msg}
		return true, err
	case 2: // node.dense_float_binary_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DenseFloatBinarySplit)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_DenseFloatBinarySplit{msg}
		return true, err
	case 3: // node.sparse_float_binary_split_default_left
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparseFloatBinarySplitDefaultLeft)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_SparseFloatBinarySplitDefaultLeft{msg}
		return true, err
	case 4: // node.sparse_float_binary_split_default_right
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparseFloatBinarySplitDefaultRight)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_SparseFloatBinarySplitDefaultRight{msg}
		return true, err
	case 5: // node.categorical_id_binary_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CategoricalIdBinarySplit)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_CategoricalIdBinarySplit{msg}
		return true, err
	case 6: // node.categorical_id_set_membership_binary_split
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CategoricalIdSetMembershipBinarySplit)
		err := b.DecodeMessage(msg)
		m.Node = &TreeNode_CategoricalIdSetMembershipBinarySplit{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TreeNode_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TreeNode)
	// node
	switch x := m.Node.(type) {
	case *TreeNode_Leaf:
		s := proto.Size(x.Leaf)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeNode_DenseFloatBinarySplit:
		s := proto.Size(x.DenseFloatBinarySplit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeNode_SparseFloatBinarySplitDefaultLeft:
		s := proto.Size(x.SparseFloatBinarySplitDefaultLeft)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeNode_SparseFloatBinarySplitDefaultRight:
		s := proto.Size(x.SparseFloatBinarySplitDefaultRight)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeNode_CategoricalIdBinarySplit:
		s := proto.Size(x.CategoricalIdBinarySplit)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TreeNode_CategoricalIdSetMembershipBinarySplit:
		s := proto.Size(x.CategoricalIdSetMembershipBinarySplit)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TreeNodeMetadata encodes metadata associated with each node in a tree.
type TreeNodeMetadata struct {
	// The gain associated with this node.
	Gain float32 `protobuf:"fixed32,1,opt,name=gain,proto3" json:"gain,omitempty"`
	// The original leaf node before this node was split.
	OriginalLeaf *Leaf `protobuf:"bytes,2,opt,name=original_leaf,json=originalLeaf" json:"original_leaf,omitempty"`
}

func (m *TreeNodeMetadata) Reset()                    { *m = TreeNodeMetadata{} }
func (*TreeNodeMetadata) ProtoMessage()               {}
func (*TreeNodeMetadata) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{1} }

func (m *TreeNodeMetadata) GetGain() float32 {
	if m != nil {
		return m.Gain
	}
	return 0
}

func (m *TreeNodeMetadata) GetOriginalLeaf() *Leaf {
	if m != nil {
		return m.OriginalLeaf
	}
	return nil
}

// Leaves can either hold dense or sparse information.
type Leaf struct {
	// Types that are valid to be assigned to Leaf:
	//	*Leaf_Vector
	//	*Leaf_SparseVector
	Leaf isLeaf_Leaf `protobuf_oneof:"leaf"`
}

func (m *Leaf) Reset()                    { *m = Leaf{} }
func (*Leaf) ProtoMessage()               {}
func (*Leaf) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{2} }

type isLeaf_Leaf interface {
	isLeaf_Leaf()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Leaf_Vector struct {
	Vector *Vector `protobuf:"bytes,1,opt,name=vector,oneof"`
}
type Leaf_SparseVector struct {
	SparseVector *SparseVector `protobuf:"bytes,2,opt,name=sparse_vector,json=sparseVector,oneof"`
}

func (*Leaf_Vector) isLeaf_Leaf()       {}
func (*Leaf_SparseVector) isLeaf_Leaf() {}

func (m *Leaf) GetLeaf() isLeaf_Leaf {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *Leaf) GetVector() *Vector {
	if x, ok := m.GetLeaf().(*Leaf_Vector); ok {
		return x.Vector
	}
	return nil
}

func (m *Leaf) GetSparseVector() *SparseVector {
	if x, ok := m.GetLeaf().(*Leaf_SparseVector); ok {
		return x.SparseVector
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Leaf) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Leaf_OneofMarshaler, _Leaf_OneofUnmarshaler, _Leaf_OneofSizer, []interface{}{
		(*Leaf_Vector)(nil),
		(*Leaf_SparseVector)(nil),
	}
}

func _Leaf_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Leaf)
	// leaf
	switch x := m.Leaf.(type) {
	case *Leaf_Vector:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Vector); err != nil {
			return err
		}
	case *Leaf_SparseVector:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparseVector); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Leaf.Leaf has unexpected type %T", x)
	}
	return nil
}

func _Leaf_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Leaf)
	switch tag {
	case 1: // leaf.vector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Vector)
		err := b.DecodeMessage(msg)
		m.Leaf = &Leaf_Vector{msg}
		return true, err
	case 2: // leaf.sparse_vector
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparseVector)
		err := b.DecodeMessage(msg)
		m.Leaf = &Leaf_SparseVector{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Leaf_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Leaf)
	// leaf
	switch x := m.Leaf.(type) {
	case *Leaf_Vector:
		s := proto.Size(x.Vector)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Leaf_SparseVector:
		s := proto.Size(x.SparseVector)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Vector struct {
	Value []float32 `protobuf:"fixed32,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *Vector) Reset()                    { *m = Vector{} }
func (*Vector) ProtoMessage()               {}
func (*Vector) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{3} }

func (m *Vector) GetValue() []float32 {
	if m != nil {
		return m.Value
	}
	return nil
}

type SparseVector struct {
	Index []int32   `protobuf:"varint,1,rep,packed,name=index" json:"index,omitempty"`
	Value []float32 `protobuf:"fixed32,2,rep,packed,name=value" json:"value,omitempty"`
}

func (m *SparseVector) Reset()                    { *m = SparseVector{} }
func (*SparseVector) ProtoMessage()               {}
func (*SparseVector) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{4} }

func (m *SparseVector) GetIndex() []int32 {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *SparseVector) GetValue() []float32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// Split rule for dense float features.
type DenseFloatBinarySplit struct {
	// Float feature column and split threshold describing
	// the rule feature <= threshold.
	FeatureColumn int32   `protobuf:"varint,1,opt,name=feature_column,json=featureColumn,proto3" json:"feature_column,omitempty"`
	Threshold     float32 `protobuf:"fixed32,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// Node children indexing into a contiguous
	// vector of nodes starting from the root.
	LeftId  int32 `protobuf:"varint,3,opt,name=left_id,json=leftId,proto3" json:"left_id,omitempty"`
	RightId int32 `protobuf:"varint,4,opt,name=right_id,json=rightId,proto3" json:"right_id,omitempty"`
}

func (m *DenseFloatBinarySplit) Reset()                    { *m = DenseFloatBinarySplit{} }
func (*DenseFloatBinarySplit) ProtoMessage()               {}
func (*DenseFloatBinarySplit) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{5} }

func (m *DenseFloatBinarySplit) GetFeatureColumn() int32 {
	if m != nil {
		return m.FeatureColumn
	}
	return 0
}

func (m *DenseFloatBinarySplit) GetThreshold() float32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *DenseFloatBinarySplit) GetLeftId() int32 {
	if m != nil {
		return m.LeftId
	}
	return 0
}

func (m *DenseFloatBinarySplit) GetRightId() int32 {
	if m != nil {
		return m.RightId
	}
	return 0
}

// Split rule for sparse float features defaulting left for missing features.
type SparseFloatBinarySplitDefaultLeft struct {
	Split *DenseFloatBinarySplit `protobuf:"bytes,1,opt,name=split" json:"split,omitempty"`
}

func (m *SparseFloatBinarySplitDefaultLeft) Reset()      { *m = SparseFloatBinarySplitDefaultLeft{} }
func (*SparseFloatBinarySplitDefaultLeft) ProtoMessage() {}
func (*SparseFloatBinarySplitDefaultLeft) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeConfig, []int{6}
}

func (m *SparseFloatBinarySplitDefaultLeft) GetSplit() *DenseFloatBinarySplit {
	if m != nil {
		return m.Split
	}
	return nil
}

// Split rule for sparse float features defaulting right for missing features.
type SparseFloatBinarySplitDefaultRight struct {
	Split *DenseFloatBinarySplit `protobuf:"bytes,1,opt,name=split" json:"split,omitempty"`
}

func (m *SparseFloatBinarySplitDefaultRight) Reset()      { *m = SparseFloatBinarySplitDefaultRight{} }
func (*SparseFloatBinarySplitDefaultRight) ProtoMessage() {}
func (*SparseFloatBinarySplitDefaultRight) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeConfig, []int{7}
}

func (m *SparseFloatBinarySplitDefaultRight) GetSplit() *DenseFloatBinarySplit {
	if m != nil {
		return m.Split
	}
	return nil
}

// Split rule for categorical features with a single feature Id.
type CategoricalIdBinarySplit struct {
	// Categorical feature column and Id describing
	// the rule feature == Id.
	FeatureColumn int32 `protobuf:"varint,1,opt,name=feature_column,json=featureColumn,proto3" json:"feature_column,omitempty"`
	FeatureId     int64 `protobuf:"varint,2,opt,name=feature_id,json=featureId,proto3" json:"feature_id,omitempty"`
	// Node children indexing into a contiguous
	// vector of nodes starting from the root.
	LeftId  int32 `protobuf:"varint,3,opt,name=left_id,json=leftId,proto3" json:"left_id,omitempty"`
	RightId int32 `protobuf:"varint,4,opt,name=right_id,json=rightId,proto3" json:"right_id,omitempty"`
}

func (m *CategoricalIdBinarySplit) Reset()      { *m = CategoricalIdBinarySplit{} }
func (*CategoricalIdBinarySplit) ProtoMessage() {}
func (*CategoricalIdBinarySplit) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeConfig, []int{8}
}

func (m *CategoricalIdBinarySplit) GetFeatureColumn() int32 {
	if m != nil {
		return m.FeatureColumn
	}
	return 0
}

func (m *CategoricalIdBinarySplit) GetFeatureId() int64 {
	if m != nil {
		return m.FeatureId
	}
	return 0
}

func (m *CategoricalIdBinarySplit) GetLeftId() int32 {
	if m != nil {
		return m.LeftId
	}
	return 0
}

func (m *CategoricalIdBinarySplit) GetRightId() int32 {
	if m != nil {
		return m.RightId
	}
	return 0
}

// Split rule for categorical features with a set of feature Ids.
type CategoricalIdSetMembershipBinarySplit struct {
	// Categorical feature column and Id describing
	// the rule feature âˆˆ feature_ids.
	FeatureColumn int32 `protobuf:"varint,1,opt,name=feature_column,json=featureColumn,proto3" json:"feature_column,omitempty"`
	// Sorted list of Ids in the set.
	FeatureIds []int64 `protobuf:"varint,2,rep,packed,name=feature_ids,json=featureIds" json:"feature_ids,omitempty"`
	// Node children indexing into a contiguous
	// vector of nodes starting from the root.
	LeftId  int32 `protobuf:"varint,3,opt,name=left_id,json=leftId,proto3" json:"left_id,omitempty"`
	RightId int32 `protobuf:"varint,4,opt,name=right_id,json=rightId,proto3" json:"right_id,omitempty"`
}

func (m *CategoricalIdSetMembershipBinarySplit) Reset()      { *m = CategoricalIdSetMembershipBinarySplit{} }
func (*CategoricalIdSetMembershipBinarySplit) ProtoMessage() {}
func (*CategoricalIdSetMembershipBinarySplit) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeConfig, []int{9}
}

func (m *CategoricalIdSetMembershipBinarySplit) GetFeatureColumn() int32 {
	if m != nil {
		return m.FeatureColumn
	}
	return 0
}

func (m *CategoricalIdSetMembershipBinarySplit) GetFeatureIds() []int64 {
	if m != nil {
		return m.FeatureIds
	}
	return nil
}

func (m *CategoricalIdSetMembershipBinarySplit) GetLeftId() int32 {
	if m != nil {
		return m.LeftId
	}
	return 0
}

func (m *CategoricalIdSetMembershipBinarySplit) GetRightId() int32 {
	if m != nil {
		return m.RightId
	}
	return 0
}

// DecisionTreeConfig describes a list of connected nodes.
// Node 0 must be the root and can carry any payload including a leaf
// in the case of representing the bias.
// Note that each node id is implicitly its index in the list of nodes.
type DecisionTreeConfig struct {
	Nodes []*TreeNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *DecisionTreeConfig) Reset()                    { *m = DecisionTreeConfig{} }
func (*DecisionTreeConfig) ProtoMessage()               {}
func (*DecisionTreeConfig) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{10} }

func (m *DecisionTreeConfig) GetNodes() []*TreeNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type DecisionTreeMetadata struct {
	// How many times tree weight was updated (due to reweighting of the final
	// ensemble, dropout, shrinkage etc).
	NumTreeWeightUpdates int32 `protobuf:"varint,1,opt,name=num_tree_weight_updates,json=numTreeWeightUpdates,proto3" json:"num_tree_weight_updates,omitempty"`
	// Number of layers grown for this tree.
	NumLayersGrown int32 `protobuf:"varint,2,opt,name=num_layers_grown,json=numLayersGrown,proto3" json:"num_layers_grown,omitempty"`
	// Whether the tree is finalized in that no more layers can be grown.
	IsFinalized bool `protobuf:"varint,3,opt,name=is_finalized,json=isFinalized,proto3" json:"is_finalized,omitempty"`
}

func (m *DecisionTreeMetadata) Reset()                    { *m = DecisionTreeMetadata{} }
func (*DecisionTreeMetadata) ProtoMessage()               {}
func (*DecisionTreeMetadata) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{11} }

func (m *DecisionTreeMetadata) GetNumTreeWeightUpdates() int32 {
	if m != nil {
		return m.NumTreeWeightUpdates
	}
	return 0
}

func (m *DecisionTreeMetadata) GetNumLayersGrown() int32 {
	if m != nil {
		return m.NumLayersGrown
	}
	return 0
}

func (m *DecisionTreeMetadata) GetIsFinalized() bool {
	if m != nil {
		return m.IsFinalized
	}
	return false
}

type GrowingMetadata struct {
	// Number of trees that we have attempted to build. After pruning, these
	// trees might have been removed.
	NumTreesAttempted int64 `protobuf:"varint,1,opt,name=num_trees_attempted,json=numTreesAttempted,proto3" json:"num_trees_attempted,omitempty"`
	// Number of layers that we have attempted to build. After pruning, these
	// layers might have been removed.
	NumLayersAttempted int64 `protobuf:"varint,2,opt,name=num_layers_attempted,json=numLayersAttempted,proto3" json:"num_layers_attempted,omitempty"`
}

func (m *GrowingMetadata) Reset()                    { *m = GrowingMetadata{} }
func (*GrowingMetadata) ProtoMessage()               {}
func (*GrowingMetadata) Descriptor() ([]byte, []int) { return fileDescriptorTreeConfig, []int{12} }

func (m *GrowingMetadata) GetNumTreesAttempted() int64 {
	if m != nil {
		return m.NumTreesAttempted
	}
	return 0
}

func (m *GrowingMetadata) GetNumLayersAttempted() int64 {
	if m != nil {
		return m.NumLayersAttempted
	}
	return 0
}

// DecisionTreeEnsembleConfig describes an ensemble of decision trees.
type DecisionTreeEnsembleConfig struct {
	Trees        []*DecisionTreeConfig   `protobuf:"bytes,1,rep,name=trees" json:"trees,omitempty"`
	TreeWeights  []float32               `protobuf:"fixed32,2,rep,packed,name=tree_weights,json=treeWeights" json:"tree_weights,omitempty"`
	TreeMetadata []*DecisionTreeMetadata `protobuf:"bytes,3,rep,name=tree_metadata,json=treeMetadata" json:"tree_metadata,omitempty"`
	// Metadata that is used during the training.
	GrowingMetadata *GrowingMetadata `protobuf:"bytes,4,opt,name=growing_metadata,json=growingMetadata" json:"growing_metadata,omitempty"`
}

func (m *DecisionTreeEnsembleConfig) Reset()      { *m = DecisionTreeEnsembleConfig{} }
func (*DecisionTreeEnsembleConfig) ProtoMessage() {}
func (*DecisionTreeEnsembleConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorTreeConfig, []int{13}
}

func (m *DecisionTreeEnsembleConfig) GetTrees() []*DecisionTreeConfig {
	if m != nil {
		return m.Trees
	}
	return nil
}

func (m *DecisionTreeEnsembleConfig) GetTreeWeights() []float32 {
	if m != nil {
		return m.TreeWeights
	}
	return nil
}

func (m *DecisionTreeEnsembleConfig) GetTreeMetadata() []*DecisionTreeMetadata {
	if m != nil {
		return m.TreeMetadata
	}
	return nil
}

func (m *DecisionTreeEnsembleConfig) GetGrowingMetadata() *GrowingMetadata {
	if m != nil {
		return m.GrowingMetadata
	}
	return nil
}

func init() {
	proto.RegisterType((*TreeNode)(nil), "tensorflow.boosted_trees.trees.TreeNode")
	proto.RegisterType((*TreeNodeMetadata)(nil), "tensorflow.boosted_trees.trees.TreeNodeMetadata")
	proto.RegisterType((*Leaf)(nil), "tensorflow.boosted_trees.trees.Leaf")
	proto.RegisterType((*Vector)(nil), "tensorflow.boosted_trees.trees.Vector")
	proto.RegisterType((*SparseVector)(nil), "tensorflow.boosted_trees.trees.SparseVector")
	proto.RegisterType((*DenseFloatBinarySplit)(nil), "tensorflow.boosted_trees.trees.DenseFloatBinarySplit")
	proto.RegisterType((*SparseFloatBinarySplitDefaultLeft)(nil), "tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultLeft")
	proto.RegisterType((*SparseFloatBinarySplitDefaultRight)(nil), "tensorflow.boosted_trees.trees.SparseFloatBinarySplitDefaultRight")
	proto.RegisterType((*CategoricalIdBinarySplit)(nil), "tensorflow.boosted_trees.trees.CategoricalIdBinarySplit")
	proto.RegisterType((*CategoricalIdSetMembershipBinarySplit)(nil), "tensorflow.boosted_trees.trees.CategoricalIdSetMembershipBinarySplit")
	proto.RegisterType((*DecisionTreeConfig)(nil), "tensorflow.boosted_trees.trees.DecisionTreeConfig")
	proto.RegisterType((*DecisionTreeMetadata)(nil), "tensorflow.boosted_trees.trees.DecisionTreeMetadata")
	proto.RegisterType((*GrowingMetadata)(nil), "tensorflow.boosted_trees.trees.GrowingMetadata")
	proto.RegisterType((*DecisionTreeEnsembleConfig)(nil), "tensorflow.boosted_trees.trees.DecisionTreeEnsembleConfig")
}
func (this *TreeNode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode)
	if !ok {
		that2, ok := that.(TreeNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Node == nil {
		if this.Node != nil {
			return false
		}
	} else if this.Node == nil {
		return false
	} else if !this.Node.Equal(that1.Node) {
		return false
	}
	if !this.NodeMetadata.Equal(that1.NodeMetadata) {
		return false
	}
	return true
}
func (this *TreeNode_Leaf) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_Leaf)
	if !ok {
		that2, ok := that.(TreeNode_Leaf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Leaf.Equal(that1.Leaf) {
		return false
	}
	return true
}
func (this *TreeNode_DenseFloatBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_DenseFloatBinarySplit)
	if !ok {
		that2, ok := that.(TreeNode_DenseFloatBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DenseFloatBinarySplit.Equal(that1.DenseFloatBinarySplit) {
		return false
	}
	return true
}
func (this *TreeNode_SparseFloatBinarySplitDefaultLeft) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_SparseFloatBinarySplitDefaultLeft)
	if !ok {
		that2, ok := that.(TreeNode_SparseFloatBinarySplitDefaultLeft)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SparseFloatBinarySplitDefaultLeft.Equal(that1.SparseFloatBinarySplitDefaultLeft) {
		return false
	}
	return true
}
func (this *TreeNode_SparseFloatBinarySplitDefaultRight) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_SparseFloatBinarySplitDefaultRight)
	if !ok {
		that2, ok := that.(TreeNode_SparseFloatBinarySplitDefaultRight)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SparseFloatBinarySplitDefaultRight.Equal(that1.SparseFloatBinarySplitDefaultRight) {
		return false
	}
	return true
}
func (this *TreeNode_CategoricalIdBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_CategoricalIdBinarySplit)
	if !ok {
		that2, ok := that.(TreeNode_CategoricalIdBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CategoricalIdBinarySplit.Equal(that1.CategoricalIdBinarySplit) {
		return false
	}
	return true
}
func (this *TreeNode_CategoricalIdSetMembershipBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNode_CategoricalIdSetMembershipBinarySplit)
	if !ok {
		that2, ok := that.(TreeNode_CategoricalIdSetMembershipBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CategoricalIdSetMembershipBinarySplit.Equal(that1.CategoricalIdSetMembershipBinarySplit) {
		return false
	}
	return true
}
func (this *TreeNodeMetadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TreeNodeMetadata)
	if !ok {
		that2, ok := that.(TreeNodeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Gain != that1.Gain {
		return false
	}
	if !this.OriginalLeaf.Equal(that1.OriginalLeaf) {
		return false
	}
	return true
}
func (this *Leaf) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Leaf)
	if !ok {
		that2, ok := that.(Leaf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if that1.Leaf == nil {
		if this.Leaf != nil {
			return false
		}
	} else if this.Leaf == nil {
		return false
	} else if !this.Leaf.Equal(that1.Leaf) {
		return false
	}
	return true
}
func (this *Leaf_Vector) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Leaf_Vector)
	if !ok {
		that2, ok := that.(Leaf_Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Vector.Equal(that1.Vector) {
		return false
	}
	return true
}
func (this *Leaf_SparseVector) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Leaf_SparseVector)
	if !ok {
		that2, ok := that.(Leaf_SparseVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SparseVector.Equal(that1.SparseVector) {
		return false
	}
	return true
}
func (this *Vector) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Vector)
	if !ok {
		that2, ok := that.(Vector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if this.Value[i] != that1.Value[i] {
			return false
		}
	}
	return true
}
func (this *SparseVector) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SparseVector)
	if !ok {
		that2, ok := that.(SparseVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Index) != len(that1.Index) {
		return false
	}
	for i := range this.Index {
		if this.Index[i] != that1.Index[i] {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if this.Value[i] != that1.Value[i] {
			return false
		}
	}
	return true
}
func (this *DenseFloatBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DenseFloatBinarySplit)
	if !ok {
		that2, ok := that.(DenseFloatBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FeatureColumn != that1.FeatureColumn {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if this.LeftId != that1.LeftId {
		return false
	}
	if this.RightId != that1.RightId {
		return false
	}
	return true
}
func (this *SparseFloatBinarySplitDefaultLeft) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SparseFloatBinarySplitDefaultLeft)
	if !ok {
		that2, ok := that.(SparseFloatBinarySplitDefaultLeft)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Split.Equal(that1.Split) {
		return false
	}
	return true
}
func (this *SparseFloatBinarySplitDefaultRight) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SparseFloatBinarySplitDefaultRight)
	if !ok {
		that2, ok := that.(SparseFloatBinarySplitDefaultRight)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Split.Equal(that1.Split) {
		return false
	}
	return true
}
func (this *CategoricalIdBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CategoricalIdBinarySplit)
	if !ok {
		that2, ok := that.(CategoricalIdBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FeatureColumn != that1.FeatureColumn {
		return false
	}
	if this.FeatureId != that1.FeatureId {
		return false
	}
	if this.LeftId != that1.LeftId {
		return false
	}
	if this.RightId != that1.RightId {
		return false
	}
	return true
}
func (this *CategoricalIdSetMembershipBinarySplit) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CategoricalIdSetMembershipBinarySplit)
	if !ok {
		that2, ok := that.(CategoricalIdSetMembershipBinarySplit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.FeatureColumn != that1.FeatureColumn {
		return false
	}
	if len(this.FeatureIds) != len(that1.FeatureIds) {
		return false
	}
	for i := range this.FeatureIds {
		if this.FeatureIds[i] != that1.FeatureIds[i] {
			return false
		}
	}
	if this.LeftId != that1.LeftId {
		return false
	}
	if this.RightId != that1.RightId {
		return false
	}
	return true
}
func (this *DecisionTreeConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DecisionTreeConfig)
	if !ok {
		that2, ok := that.(DecisionTreeConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Nodes) != len(that1.Nodes) {
		return false
	}
	for i := range this.Nodes {
		if !this.Nodes[i].Equal(that1.Nodes[i]) {
			return false
		}
	}
	return true
}
func (this *DecisionTreeMetadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DecisionTreeMetadata)
	if !ok {
		that2, ok := that.(DecisionTreeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumTreeWeightUpdates != that1.NumTreeWeightUpdates {
		return false
	}
	if this.NumLayersGrown != that1.NumLayersGrown {
		return false
	}
	if this.IsFinalized != that1.IsFinalized {
		return false
	}
	return true
}
func (this *GrowingMetadata) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*GrowingMetadata)
	if !ok {
		that2, ok := that.(GrowingMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.NumTreesAttempted != that1.NumTreesAttempted {
		return false
	}
	if this.NumLayersAttempted != that1.NumLayersAttempted {
		return false
	}
	return true
}
func (this *DecisionTreeEnsembleConfig) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DecisionTreeEnsembleConfig)
	if !ok {
		that2, ok := that.(DecisionTreeEnsembleConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Trees) != len(that1.Trees) {
		return false
	}
	for i := range this.Trees {
		if !this.Trees[i].Equal(that1.Trees[i]) {
			return false
		}
	}
	if len(this.TreeWeights) != len(that1.TreeWeights) {
		return false
	}
	for i := range this.TreeWeights {
		if this.TreeWeights[i] != that1.TreeWeights[i] {
			return false
		}
	}
	if len(this.TreeMetadata) != len(that1.TreeMetadata) {
		return false
	}
	for i := range this.TreeMetadata {
		if !this.TreeMetadata[i].Equal(that1.TreeMetadata[i]) {
			return false
		}
	}
	if !this.GrowingMetadata.Equal(that1.GrowingMetadata) {
		return false
	}
	return true
}
func (this *TreeNode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&tensorflow_boosted_trees_trees.TreeNode{")
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	if this.NodeMetadata != nil {
		s = append(s, "NodeMetadata: "+fmt.Sprintf("%#v", this.NodeMetadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TreeNode_Leaf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_Leaf{` +
		`Leaf:` + fmt.Sprintf("%#v", this.Leaf) + `}`}, ", ")
	return s
}
func (this *TreeNode_DenseFloatBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_DenseFloatBinarySplit{` +
		`DenseFloatBinarySplit:` + fmt.Sprintf("%#v", this.DenseFloatBinarySplit) + `}`}, ", ")
	return s
}
func (this *TreeNode_SparseFloatBinarySplitDefaultLeft) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_SparseFloatBinarySplitDefaultLeft{` +
		`SparseFloatBinarySplitDefaultLeft:` + fmt.Sprintf("%#v", this.SparseFloatBinarySplitDefaultLeft) + `}`}, ", ")
	return s
}
func (this *TreeNode_SparseFloatBinarySplitDefaultRight) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_SparseFloatBinarySplitDefaultRight{` +
		`SparseFloatBinarySplitDefaultRight:` + fmt.Sprintf("%#v", this.SparseFloatBinarySplitDefaultRight) + `}`}, ", ")
	return s
}
func (this *TreeNode_CategoricalIdBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_CategoricalIdBinarySplit{` +
		`CategoricalIdBinarySplit:` + fmt.Sprintf("%#v", this.CategoricalIdBinarySplit) + `}`}, ", ")
	return s
}
func (this *TreeNode_CategoricalIdSetMembershipBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.TreeNode_CategoricalIdSetMembershipBinarySplit{` +
		`CategoricalIdSetMembershipBinarySplit:` + fmt.Sprintf("%#v", this.CategoricalIdSetMembershipBinarySplit) + `}`}, ", ")
	return s
}
func (this *TreeNodeMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_trees.TreeNodeMetadata{")
	s = append(s, "Gain: "+fmt.Sprintf("%#v", this.Gain)+",\n")
	if this.OriginalLeaf != nil {
		s = append(s, "OriginalLeaf: "+fmt.Sprintf("%#v", this.OriginalLeaf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Leaf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_trees.Leaf{")
	if this.Leaf != nil {
		s = append(s, "Leaf: "+fmt.Sprintf("%#v", this.Leaf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Leaf_Vector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.Leaf_Vector{` +
		`Vector:` + fmt.Sprintf("%#v", this.Vector) + `}`}, ", ")
	return s
}
func (this *Leaf_SparseVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tensorflow_boosted_trees_trees.Leaf_SparseVector{` +
		`SparseVector:` + fmt.Sprintf("%#v", this.SparseVector) + `}`}, ", ")
	return s
}
func (this *Vector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_boosted_trees_trees.Vector{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_trees.SparseVector{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DenseFloatBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_boosted_trees_trees.DenseFloatBinarySplit{")
	s = append(s, "FeatureColumn: "+fmt.Sprintf("%#v", this.FeatureColumn)+",\n")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "LeftId: "+fmt.Sprintf("%#v", this.LeftId)+",\n")
	s = append(s, "RightId: "+fmt.Sprintf("%#v", this.RightId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseFloatBinarySplitDefaultLeft) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_boosted_trees_trees.SparseFloatBinarySplitDefaultLeft{")
	if this.Split != nil {
		s = append(s, "Split: "+fmt.Sprintf("%#v", this.Split)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseFloatBinarySplitDefaultRight) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_boosted_trees_trees.SparseFloatBinarySplitDefaultRight{")
	if this.Split != nil {
		s = append(s, "Split: "+fmt.Sprintf("%#v", this.Split)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CategoricalIdBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_boosted_trees_trees.CategoricalIdBinarySplit{")
	s = append(s, "FeatureColumn: "+fmt.Sprintf("%#v", this.FeatureColumn)+",\n")
	s = append(s, "FeatureId: "+fmt.Sprintf("%#v", this.FeatureId)+",\n")
	s = append(s, "LeftId: "+fmt.Sprintf("%#v", this.LeftId)+",\n")
	s = append(s, "RightId: "+fmt.Sprintf("%#v", this.RightId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CategoricalIdSetMembershipBinarySplit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_boosted_trees_trees.CategoricalIdSetMembershipBinarySplit{")
	s = append(s, "FeatureColumn: "+fmt.Sprintf("%#v", this.FeatureColumn)+",\n")
	s = append(s, "FeatureIds: "+fmt.Sprintf("%#v", this.FeatureIds)+",\n")
	s = append(s, "LeftId: "+fmt.Sprintf("%#v", this.LeftId)+",\n")
	s = append(s, "RightId: "+fmt.Sprintf("%#v", this.RightId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DecisionTreeConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tensorflow_boosted_trees_trees.DecisionTreeConfig{")
	if this.Nodes != nil {
		s = append(s, "Nodes: "+fmt.Sprintf("%#v", this.Nodes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DecisionTreeMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tensorflow_boosted_trees_trees.DecisionTreeMetadata{")
	s = append(s, "NumTreeWeightUpdates: "+fmt.Sprintf("%#v", this.NumTreeWeightUpdates)+",\n")
	s = append(s, "NumLayersGrown: "+fmt.Sprintf("%#v", this.NumLayersGrown)+",\n")
	s = append(s, "IsFinalized: "+fmt.Sprintf("%#v", this.IsFinalized)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GrowingMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tensorflow_boosted_trees_trees.GrowingMetadata{")
	s = append(s, "NumTreesAttempted: "+fmt.Sprintf("%#v", this.NumTreesAttempted)+",\n")
	s = append(s, "NumLayersAttempted: "+fmt.Sprintf("%#v", this.NumLayersAttempted)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DecisionTreeEnsembleConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tensorflow_boosted_trees_trees.DecisionTreeEnsembleConfig{")
	if this.Trees != nil {
		s = append(s, "Trees: "+fmt.Sprintf("%#v", this.Trees)+",\n")
	}
	s = append(s, "TreeWeights: "+fmt.Sprintf("%#v", this.TreeWeights)+",\n")
	if this.TreeMetadata != nil {
		s = append(s, "TreeMetadata: "+fmt.Sprintf("%#v", this.TreeMetadata)+",\n")
	}
	if this.GrowingMetadata != nil {
		s = append(s, "GrowingMetadata: "+fmt.Sprintf("%#v", this.GrowingMetadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTreeConfig(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *TreeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		nn1, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.NodeMetadata != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x30
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.NodeMetadata.Size()))
		n2, err := m.NodeMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *TreeNode_Leaf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Leaf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.Leaf.Size()))
		n3, err := m.Leaf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *TreeNode_DenseFloatBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DenseFloatBinarySplit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.DenseFloatBinarySplit.Size()))
		n4, err := m.DenseFloatBinarySplit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *TreeNode_SparseFloatBinarySplitDefaultLeft) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseFloatBinarySplitDefaultLeft != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.SparseFloatBinarySplitDefaultLeft.Size()))
		n5, err := m.SparseFloatBinarySplitDefaultLeft.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *TreeNode_SparseFloatBinarySplitDefaultRight) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseFloatBinarySplitDefaultRight != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.SparseFloatBinarySplitDefaultRight.Size()))
		n6, err := m.SparseFloatBinarySplitDefaultRight.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *TreeNode_CategoricalIdBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CategoricalIdBinarySplit != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.CategoricalIdBinarySplit.Size()))
		n7, err := m.CategoricalIdBinarySplit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *TreeNode_CategoricalIdSetMembershipBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CategoricalIdSetMembershipBinarySplit != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.CategoricalIdSetMembershipBinarySplit.Size()))
		n8, err := m.CategoricalIdSetMembershipBinarySplit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *TreeNodeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeNodeMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gain != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32TreeConfig(dAtA, i, uint32(math.Float32bits(float32(m.Gain))))
	}
	if m.OriginalLeaf != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.OriginalLeaf.Size()))
		n9, err := m.OriginalLeaf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *Leaf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leaf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Leaf != nil {
		nn10, err := m.Leaf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	return i, nil
}

func (m *Leaf_Vector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Vector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.Vector.Size()))
		n11, err := m.Vector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Leaf_SparseVector) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.SparseVector != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.SparseVector.Size()))
		n12, err := m.SparseVector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Vector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(len(m.Value)*4))
		for _, num := range m.Value {
			f13 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f13)
			i++
			dAtA[i] = uint8(f13 >> 8)
			i++
			dAtA[i] = uint8(f13 >> 16)
			i++
			dAtA[i] = uint8(f13 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *SparseVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseVector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		dAtA15 := make([]byte, len(m.Index)*10)
		var j14 int
		for _, num1 := range m.Index {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(len(m.Value)*4))
		for _, num := range m.Value {
			f16 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f16)
			i++
			dAtA[i] = uint8(f16 >> 8)
			i++
			dAtA[i] = uint8(f16 >> 16)
			i++
			dAtA[i] = uint8(f16 >> 24)
			i++
		}
	}
	return i, nil
}

func (m *DenseFloatBinarySplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DenseFloatBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.FeatureColumn))
	}
	if m.Threshold != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32TreeConfig(dAtA, i, uint32(math.Float32bits(float32(m.Threshold))))
	}
	if m.LeftId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.LeftId))
	}
	if m.RightId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.RightId))
	}
	return i, nil
}

func (m *SparseFloatBinarySplitDefaultLeft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseFloatBinarySplitDefaultLeft) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Split != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.Split.Size()))
		n17, err := m.Split.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *SparseFloatBinarySplitDefaultRight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseFloatBinarySplitDefaultRight) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Split != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.Split.Size()))
		n18, err := m.Split.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *CategoricalIdBinarySplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoricalIdBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.FeatureColumn))
	}
	if m.FeatureId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.FeatureId))
	}
	if m.LeftId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.LeftId))
	}
	if m.RightId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.RightId))
	}
	return i, nil
}

func (m *CategoricalIdSetMembershipBinarySplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoricalIdSetMembershipBinarySplit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.FeatureColumn))
	}
	if len(m.FeatureIds) > 0 {
		dAtA20 := make([]byte, len(m.FeatureIds)*10)
		var j19 int
		for _, num1 := range m.FeatureIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if m.LeftId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.LeftId))
	}
	if m.RightId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.RightId))
	}
	return i, nil
}

func (m *DecisionTreeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionTreeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTreeConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DecisionTreeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionTreeMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTreeWeightUpdates != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.NumTreeWeightUpdates))
	}
	if m.NumLayersGrown != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.NumLayersGrown))
	}
	if m.IsFinalized {
		dAtA[i] = 0x18
		i++
		if m.IsFinalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GrowingMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GrowingMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NumTreesAttempted != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.NumTreesAttempted))
	}
	if m.NumLayersAttempted != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.NumLayersAttempted))
	}
	return i, nil
}

func (m *DecisionTreeEnsembleConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionTreeEnsembleConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Trees) > 0 {
		for _, msg := range m.Trees {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTreeConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TreeWeights) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(len(m.TreeWeights)*4))
		for _, num := range m.TreeWeights {
			f21 := math.Float32bits(float32(num))
			dAtA[i] = uint8(f21)
			i++
			dAtA[i] = uint8(f21 >> 8)
			i++
			dAtA[i] = uint8(f21 >> 16)
			i++
			dAtA[i] = uint8(f21 >> 24)
			i++
		}
	}
	if len(m.TreeMetadata) > 0 {
		for _, msg := range m.TreeMetadata {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTreeConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GrowingMetadata != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTreeConfig(dAtA, i, uint64(m.GrowingMetadata.Size()))
		n22, err := m.GrowingMetadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func encodeFixed64TreeConfig(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TreeConfig(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTreeConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TreeNode) Size() (n int) {
	var l int
	_ = l
	if m.Node != nil {
		n += m.Node.Size()
	}
	if m.NodeMetadata != nil {
		l = m.NodeMetadata.Size()
		n += 2 + l + sovTreeConfig(uint64(l))
	}
	return n
}

func (m *TreeNode_Leaf) Size() (n int) {
	var l int
	_ = l
	if m.Leaf != nil {
		l = m.Leaf.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNode_DenseFloatBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.DenseFloatBinarySplit != nil {
		l = m.DenseFloatBinarySplit.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNode_SparseFloatBinarySplitDefaultLeft) Size() (n int) {
	var l int
	_ = l
	if m.SparseFloatBinarySplitDefaultLeft != nil {
		l = m.SparseFloatBinarySplitDefaultLeft.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNode_SparseFloatBinarySplitDefaultRight) Size() (n int) {
	var l int
	_ = l
	if m.SparseFloatBinarySplitDefaultRight != nil {
		l = m.SparseFloatBinarySplitDefaultRight.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNode_CategoricalIdBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.CategoricalIdBinarySplit != nil {
		l = m.CategoricalIdBinarySplit.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNode_CategoricalIdSetMembershipBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.CategoricalIdSetMembershipBinarySplit != nil {
		l = m.CategoricalIdSetMembershipBinarySplit.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *TreeNodeMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Gain != 0 {
		n += 5
	}
	if m.OriginalLeaf != nil {
		l = m.OriginalLeaf.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}

func (m *Leaf) Size() (n int) {
	var l int
	_ = l
	if m.Leaf != nil {
		n += m.Leaf.Size()
	}
	return n
}

func (m *Leaf_Vector) Size() (n int) {
	var l int
	_ = l
	if m.Vector != nil {
		l = m.Vector.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *Leaf_SparseVector) Size() (n int) {
	var l int
	_ = l
	if m.SparseVector != nil {
		l = m.SparseVector.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}
func (m *Vector) Size() (n int) {
	var l int
	_ = l
	if len(m.Value) > 0 {
		n += 1 + sovTreeConfig(uint64(len(m.Value)*4)) + len(m.Value)*4
	}
	return n
}

func (m *SparseVector) Size() (n int) {
	var l int
	_ = l
	if len(m.Index) > 0 {
		l = 0
		for _, e := range m.Index {
			l += sovTreeConfig(uint64(e))
		}
		n += 1 + sovTreeConfig(uint64(l)) + l
	}
	if len(m.Value) > 0 {
		n += 1 + sovTreeConfig(uint64(len(m.Value)*4)) + len(m.Value)*4
	}
	return n
}

func (m *DenseFloatBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		n += 1 + sovTreeConfig(uint64(m.FeatureColumn))
	}
	if m.Threshold != 0 {
		n += 5
	}
	if m.LeftId != 0 {
		n += 1 + sovTreeConfig(uint64(m.LeftId))
	}
	if m.RightId != 0 {
		n += 1 + sovTreeConfig(uint64(m.RightId))
	}
	return n
}

func (m *SparseFloatBinarySplitDefaultLeft) Size() (n int) {
	var l int
	_ = l
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}

func (m *SparseFloatBinarySplitDefaultRight) Size() (n int) {
	var l int
	_ = l
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}

func (m *CategoricalIdBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		n += 1 + sovTreeConfig(uint64(m.FeatureColumn))
	}
	if m.FeatureId != 0 {
		n += 1 + sovTreeConfig(uint64(m.FeatureId))
	}
	if m.LeftId != 0 {
		n += 1 + sovTreeConfig(uint64(m.LeftId))
	}
	if m.RightId != 0 {
		n += 1 + sovTreeConfig(uint64(m.RightId))
	}
	return n
}

func (m *CategoricalIdSetMembershipBinarySplit) Size() (n int) {
	var l int
	_ = l
	if m.FeatureColumn != 0 {
		n += 1 + sovTreeConfig(uint64(m.FeatureColumn))
	}
	if len(m.FeatureIds) > 0 {
		l = 0
		for _, e := range m.FeatureIds {
			l += sovTreeConfig(uint64(e))
		}
		n += 1 + sovTreeConfig(uint64(l)) + l
	}
	if m.LeftId != 0 {
		n += 1 + sovTreeConfig(uint64(m.LeftId))
	}
	if m.RightId != 0 {
		n += 1 + sovTreeConfig(uint64(m.RightId))
	}
	return n
}

func (m *DecisionTreeConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovTreeConfig(uint64(l))
		}
	}
	return n
}

func (m *DecisionTreeMetadata) Size() (n int) {
	var l int
	_ = l
	if m.NumTreeWeightUpdates != 0 {
		n += 1 + sovTreeConfig(uint64(m.NumTreeWeightUpdates))
	}
	if m.NumLayersGrown != 0 {
		n += 1 + sovTreeConfig(uint64(m.NumLayersGrown))
	}
	if m.IsFinalized {
		n += 2
	}
	return n
}

func (m *GrowingMetadata) Size() (n int) {
	var l int
	_ = l
	if m.NumTreesAttempted != 0 {
		n += 1 + sovTreeConfig(uint64(m.NumTreesAttempted))
	}
	if m.NumLayersAttempted != 0 {
		n += 1 + sovTreeConfig(uint64(m.NumLayersAttempted))
	}
	return n
}

func (m *DecisionTreeEnsembleConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Trees) > 0 {
		for _, e := range m.Trees {
			l = e.Size()
			n += 1 + l + sovTreeConfig(uint64(l))
		}
	}
	if len(m.TreeWeights) > 0 {
		n += 1 + sovTreeConfig(uint64(len(m.TreeWeights)*4)) + len(m.TreeWeights)*4
	}
	if len(m.TreeMetadata) > 0 {
		for _, e := range m.TreeMetadata {
			l = e.Size()
			n += 1 + l + sovTreeConfig(uint64(l))
		}
	}
	if m.GrowingMetadata != nil {
		l = m.GrowingMetadata.Size()
		n += 1 + l + sovTreeConfig(uint64(l))
	}
	return n
}

func sovTreeConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTreeConfig(x uint64) (n int) {
	return sovTreeConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *TreeNode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`NodeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.NodeMetadata), "TreeNodeMetadata", "TreeNodeMetadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_Leaf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_Leaf{`,
		`Leaf:` + strings.Replace(fmt.Sprintf("%v", this.Leaf), "Leaf", "Leaf", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_DenseFloatBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_DenseFloatBinarySplit{`,
		`DenseFloatBinarySplit:` + strings.Replace(fmt.Sprintf("%v", this.DenseFloatBinarySplit), "DenseFloatBinarySplit", "DenseFloatBinarySplit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_SparseFloatBinarySplitDefaultLeft) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_SparseFloatBinarySplitDefaultLeft{`,
		`SparseFloatBinarySplitDefaultLeft:` + strings.Replace(fmt.Sprintf("%v", this.SparseFloatBinarySplitDefaultLeft), "SparseFloatBinarySplitDefaultLeft", "SparseFloatBinarySplitDefaultLeft", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_SparseFloatBinarySplitDefaultRight) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_SparseFloatBinarySplitDefaultRight{`,
		`SparseFloatBinarySplitDefaultRight:` + strings.Replace(fmt.Sprintf("%v", this.SparseFloatBinarySplitDefaultRight), "SparseFloatBinarySplitDefaultRight", "SparseFloatBinarySplitDefaultRight", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_CategoricalIdBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_CategoricalIdBinarySplit{`,
		`CategoricalIdBinarySplit:` + strings.Replace(fmt.Sprintf("%v", this.CategoricalIdBinarySplit), "CategoricalIdBinarySplit", "CategoricalIdBinarySplit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNode_CategoricalIdSetMembershipBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNode_CategoricalIdSetMembershipBinarySplit{`,
		`CategoricalIdSetMembershipBinarySplit:` + strings.Replace(fmt.Sprintf("%v", this.CategoricalIdSetMembershipBinarySplit), "CategoricalIdSetMembershipBinarySplit", "CategoricalIdSetMembershipBinarySplit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TreeNodeMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TreeNodeMetadata{`,
		`Gain:` + fmt.Sprintf("%v", this.Gain) + `,`,
		`OriginalLeaf:` + strings.Replace(fmt.Sprintf("%v", this.OriginalLeaf), "Leaf", "Leaf", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Leaf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Leaf{`,
		`Leaf:` + fmt.Sprintf("%v", this.Leaf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Leaf_Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Leaf_Vector{`,
		`Vector:` + strings.Replace(fmt.Sprintf("%v", this.Vector), "Vector", "Vector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Leaf_SparseVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Leaf_SparseVector{`,
		`SparseVector:` + strings.Replace(fmt.Sprintf("%v", this.SparseVector), "SparseVector", "SparseVector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Vector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Vector{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseVector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseVector{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DenseFloatBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DenseFloatBinarySplit{`,
		`FeatureColumn:` + fmt.Sprintf("%v", this.FeatureColumn) + `,`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`LeftId:` + fmt.Sprintf("%v", this.LeftId) + `,`,
		`RightId:` + fmt.Sprintf("%v", this.RightId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseFloatBinarySplitDefaultLeft) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseFloatBinarySplitDefaultLeft{`,
		`Split:` + strings.Replace(fmt.Sprintf("%v", this.Split), "DenseFloatBinarySplit", "DenseFloatBinarySplit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseFloatBinarySplitDefaultRight) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseFloatBinarySplitDefaultRight{`,
		`Split:` + strings.Replace(fmt.Sprintf("%v", this.Split), "DenseFloatBinarySplit", "DenseFloatBinarySplit", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CategoricalIdBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CategoricalIdBinarySplit{`,
		`FeatureColumn:` + fmt.Sprintf("%v", this.FeatureColumn) + `,`,
		`FeatureId:` + fmt.Sprintf("%v", this.FeatureId) + `,`,
		`LeftId:` + fmt.Sprintf("%v", this.LeftId) + `,`,
		`RightId:` + fmt.Sprintf("%v", this.RightId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CategoricalIdSetMembershipBinarySplit) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CategoricalIdSetMembershipBinarySplit{`,
		`FeatureColumn:` + fmt.Sprintf("%v", this.FeatureColumn) + `,`,
		`FeatureIds:` + fmt.Sprintf("%v", this.FeatureIds) + `,`,
		`LeftId:` + fmt.Sprintf("%v", this.LeftId) + `,`,
		`RightId:` + fmt.Sprintf("%v", this.RightId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DecisionTreeConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DecisionTreeConfig{`,
		`Nodes:` + strings.Replace(fmt.Sprintf("%v", this.Nodes), "TreeNode", "TreeNode", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DecisionTreeMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DecisionTreeMetadata{`,
		`NumTreeWeightUpdates:` + fmt.Sprintf("%v", this.NumTreeWeightUpdates) + `,`,
		`NumLayersGrown:` + fmt.Sprintf("%v", this.NumLayersGrown) + `,`,
		`IsFinalized:` + fmt.Sprintf("%v", this.IsFinalized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GrowingMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GrowingMetadata{`,
		`NumTreesAttempted:` + fmt.Sprintf("%v", this.NumTreesAttempted) + `,`,
		`NumLayersAttempted:` + fmt.Sprintf("%v", this.NumLayersAttempted) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DecisionTreeEnsembleConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DecisionTreeEnsembleConfig{`,
		`Trees:` + strings.Replace(fmt.Sprintf("%v", this.Trees), "DecisionTreeConfig", "DecisionTreeConfig", 1) + `,`,
		`TreeWeights:` + fmt.Sprintf("%v", this.TreeWeights) + `,`,
		`TreeMetadata:` + strings.Replace(fmt.Sprintf("%v", this.TreeMetadata), "DecisionTreeMetadata", "DecisionTreeMetadata", 1) + `,`,
		`GrowingMetadata:` + strings.Replace(fmt.Sprintf("%v", this.GrowingMetadata), "GrowingMetadata", "GrowingMetadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTreeConfig(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *TreeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Leaf{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_Leaf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenseFloatBinarySplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DenseFloatBinarySplit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_DenseFloatBinarySplit{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseFloatBinarySplitDefaultLeft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseFloatBinarySplitDefaultLeft{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_SparseFloatBinarySplitDefaultLeft{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseFloatBinarySplitDefaultRight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseFloatBinarySplitDefaultRight{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_SparseFloatBinarySplitDefaultRight{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoricalIdBinarySplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CategoricalIdBinarySplit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_CategoricalIdBinarySplit{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CategoricalIdSetMembershipBinarySplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CategoricalIdSetMembershipBinarySplit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Node = &TreeNode_CategoricalIdSetMembershipBinarySplit{v}
			iNdEx = postIndex
		case 777:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeMetadata == nil {
				m.NodeMetadata = &TreeNodeMetadata{}
			}
			if err := m.NodeMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeNodeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNodeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNodeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Gain = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalLeaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginalLeaf == nil {
				m.OriginalLeaf = &Leaf{}
			}
			if err := m.OriginalLeaf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leaf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leaf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leaf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Vector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Leaf = &Leaf_Vector{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SparseVector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SparseVector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Leaf = &Leaf_SparseVector{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Value = append(m.Value, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Value = append(m.Value, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Index = append(m.Index, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreeConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Index = append(m.Index, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.Value = append(m.Value, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.Value = append(m.Value, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DenseFloatBinarySplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DenseFloatBinarySplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DenseFloatBinarySplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureColumn", wireType)
			}
			m.FeatureColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureColumn |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Threshold = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftId", wireType)
			}
			m.LeftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightId", wireType)
			}
			m.RightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseFloatBinarySplitDefaultLeft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseFloatBinarySplitDefaultLeft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseFloatBinarySplitDefaultLeft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &DenseFloatBinarySplit{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseFloatBinarySplitDefaultRight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseFloatBinarySplitDefaultRight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseFloatBinarySplitDefaultRight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &DenseFloatBinarySplit{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoricalIdBinarySplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoricalIdBinarySplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoricalIdBinarySplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureColumn", wireType)
			}
			m.FeatureColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureColumn |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureId", wireType)
			}
			m.FeatureId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftId", wireType)
			}
			m.LeftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightId", wireType)
			}
			m.RightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoricalIdSetMembershipBinarySplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoricalIdSetMembershipBinarySplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoricalIdSetMembershipBinarySplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureColumn", wireType)
			}
			m.FeatureColumn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureColumn |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FeatureIds = append(m.FeatureIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreeConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FeatureIds = append(m.FeatureIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftId", wireType)
			}
			m.LeftId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightId", wireType)
			}
			m.RightId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionTreeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionTreeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionTreeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &TreeNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionTreeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionTreeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionTreeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTreeWeightUpdates", wireType)
			}
			m.NumTreeWeightUpdates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTreeWeightUpdates |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLayersGrown", wireType)
			}
			m.NumLayersGrown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLayersGrown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFinalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GrowingMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GrowingMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GrowingMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTreesAttempted", wireType)
			}
			m.NumTreesAttempted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTreesAttempted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLayersAttempted", wireType)
			}
			m.NumLayersAttempted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLayersAttempted |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionTreeEnsembleConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionTreeEnsembleConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionTreeEnsembleConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trees = append(m.Trees, &DecisionTreeConfig{})
			if err := m.Trees[len(m.Trees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 4
				v = uint32(dAtA[iNdEx-4])
				v |= uint32(dAtA[iNdEx-3]) << 8
				v |= uint32(dAtA[iNdEx-2]) << 16
				v |= uint32(dAtA[iNdEx-1]) << 24
				v2 := float32(math.Float32frombits(v))
				m.TreeWeights = append(m.TreeWeights, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreeConfig
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 4
					v = uint32(dAtA[iNdEx-4])
					v |= uint32(dAtA[iNdEx-3]) << 8
					v |= uint32(dAtA[iNdEx-2]) << 16
					v |= uint32(dAtA[iNdEx-1]) << 24
					v2 := float32(math.Float32frombits(v))
					m.TreeWeights = append(m.TreeWeights, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeWeights", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreeMetadata = append(m.TreeMetadata, &DecisionTreeMetadata{})
			if err := m.TreeMetadata[len(m.TreeMetadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowingMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreeConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrowingMetadata == nil {
				m.GrowingMetadata = &GrowingMetadata{}
			}
			if err := m.GrowingMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreeConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreeConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTreeConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTreeConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreeConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTreeConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTreeConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTreeConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTreeConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTreeConfig   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("protobuf/tensorflow/contrib/boosted_trees/proto/tree_config.proto", fileDescriptorTreeConfig)
}

var fileDescriptorTreeConfig = []byte{
	// 970 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x8f, 0xdb, 0xc4,
	0x17, 0xcf, 0xe4, 0x57, 0xb7, 0x2f, 0x49, 0xbb, 0xdf, 0xf9, 0x6e, 0xd5, 0xf0, 0xcb, 0x74, 0x2d,
	0xb6, 0xac, 0x10, 0x4a, 0xaa, 0x85, 0x4a, 0xa8, 0x07, 0xc4, 0xfe, 0x68, 0x49, 0xc4, 0x96, 0xc3,
	0x6c, 0x29, 0x82, 0x8b, 0x35, 0x89, 0xc7, 0xd9, 0x91, 0x1c, 0x3b, 0xf5, 0x8c, 0xbb, 0x2c, 0x27,
	0xae, 0xdc, 0x7a, 0x40, 0x48, 0x70, 0x04, 0x21, 0xf1, 0x67, 0x70, 0xe4, 0xd8, 0x23, 0x47, 0x36,
	0x5c, 0xb8, 0x20, 0xf5, 0xc8, 0x11, 0xcd, 0xb3, 0xe3, 0x38, 0xd1, 0x16, 0xa7, 0x2d, 0x97, 0xc8,
	0xf3, 0xe6, 0x7d, 0x3e, 0xef, 0x93, 0x37, 0xf3, 0x3e, 0x36, 0xec, 0x4e, 0xa2, 0x50, 0x87, 0x83,
	0xd8, 0xeb, 0x6a, 0x11, 0xa8, 0x30, 0xf2, 0xfc, 0xf0, 0xa4, 0x3b, 0x0c, 0x03, 0x1d, 0xc9, 0x41,
	0x77, 0x10, 0x86, 0x4a, 0x0b, 0xd7, 0xd1, 0x91, 0x10, 0xaa, 0x8b, 0x99, 0x5d, 0xf3, 0xec, 0x0c,
	0xc3, 0xc0, 0x93, 0xa3, 0x0e, 0x46, 0xa8, 0x35, 0x47, 0x76, 0x16, 0x10, 0x1d, 0xfc, 0xb5, 0xff,
	0xaa, 0xc3, 0xda, 0xbd, 0x48, 0x88, 0x8f, 0x43, 0x57, 0xd0, 0x5b, 0x50, 0xf5, 0x05, 0xf7, 0xda,
	0xe4, 0x1a, 0xd9, 0x6e, 0xec, 0xbc, 0xd1, 0xf9, 0x77, 0x6c, 0xe7, 0x50, 0x70, 0xaf, 0x57, 0x62,
	0x88, 0xa1, 0x13, 0x68, 0xbb, 0x22, 0x50, 0xc2, 0xf1, 0xfc, 0x90, 0x6b, 0x67, 0x20, 0x03, 0x1e,
	0x9d, 0x3a, 0x6a, 0xe2, 0x4b, 0xdd, 0x2e, 0x23, 0xdf, 0xcd, 0x22, 0xbe, 0x03, 0x83, 0xbf, 0x63,
	0xe0, 0x7b, 0x88, 0x3e, 0x32, 0xe0, 0x5e, 0x89, 0x5d, 0x71, 0xcf, 0xdb, 0xa0, 0xdf, 0x12, 0xb8,
	0xae, 0x26, 0x3c, 0x3a, 0xb7, 0xa6, 0xe3, 0x0a, 0x8f, 0xc7, 0xbe, 0x76, 0x7c, 0xe1, 0xe9, 0x76,
	0x05, 0x05, 0xec, 0x16, 0x09, 0x38, 0x42, 0xb6, 0xe5, 0x42, 0x07, 0x09, 0xd3, 0xa1, 0xf0, 0x8c,
	0x98, 0x4d, 0x55, 0x94, 0x44, 0xbf, 0x23, 0xf0, 0x66, 0xb1, 0xb0, 0x48, 0x8e, 0x8e, 0x75, 0xbb,
	0x8a, 0xca, 0xf6, 0x5e, 0x48, 0x19, 0x33, 0x4c, 0xbd, 0x12, 0xb3, 0x55, 0x61, 0x16, 0x3d, 0x85,
	0x57, 0x86, 0x5c, 0x8b, 0x51, 0x18, 0xc9, 0x21, 0xf7, 0x1d, 0xe9, 0x2e, 0x9e, 0x54, 0x0d, 0xe5,
	0xbc, 0x57, 0x24, 0x67, 0x7f, 0x4e, 0xd1, 0x77, 0x17, 0x0f, 0xab, 0x3d, 0x7c, 0xca, 0x1e, 0xfd,
	0x81, 0xc0, 0x5b, 0x4b, 0xb5, 0x95, 0xd0, 0xce, 0x58, 0x8c, 0x07, 0x22, 0x52, 0xc7, 0x72, 0xb2,
	0x28, 0xa5, 0x8e, 0x52, 0x6e, 0x3f, 0x93, 0x94, 0x23, 0xa1, 0xef, 0x66, 0x74, 0x8b, 0xba, 0xb6,
	0x86, 0xab, 0x24, 0xd2, 0xfb, 0xd0, 0x0a, 0x42, 0x57, 0x38, 0x63, 0xa1, 0xb9, 0xcb, 0x35, 0x6f,
	0x7f, 0x9d, 0xe8, 0xb8, 0x51, 0xa4, 0x63, 0x36, 0x44, 0x77, 0x53, 0x20, 0x6b, 0x06, 0xb9, 0xd5,
	0x5e, 0x1d, 0xaa, 0x66, 0x6d, 0x3f, 0x80, 0xf5, 0xe5, 0x4c, 0x4a, 0xa1, 0x3a, 0xe2, 0x32, 0xc0,
	0xb1, 0x2b, 0x33, 0x7c, 0xa6, 0x7d, 0x68, 0x85, 0x91, 0x1c, 0xc9, 0x80, 0xfb, 0x0e, 0xce, 0x64,
	0x79, 0xf5, 0x99, 0x64, 0xcd, 0x19, 0xd4, 0xac, 0xec, 0x9f, 0x08, 0x54, 0xcd, 0x03, 0xfd, 0x00,
	0xea, 0x0f, 0xc5, 0x50, 0x87, 0x51, 0x3a, 0xe0, 0xd7, 0x8b, 0xc8, 0xee, 0x63, 0x76, 0xaf, 0xc4,
	0x52, 0x1c, 0x3d, 0x82, 0x56, 0x7a, 0xb1, 0x53, 0xa2, 0x44, 0xd5, 0xdb, 0xab, 0x5d, 0xdf, 0x8c,
	0xae, 0xa9, 0x72, 0x6b, 0xd3, 0x1a, 0xf3, 0x0f, 0x6d, 0x0b, 0xea, 0x49, 0x84, 0x6e, 0x40, 0xed,
	0x21, 0xf7, 0x63, 0xd1, 0x26, 0xd7, 0x2a, 0xdb, 0x65, 0x96, 0x2c, 0xec, 0x5b, 0xd0, 0xcc, 0xf3,
	0x98, 0x2c, 0x19, 0xb8, 0xe2, 0x0b, 0xcc, 0xaa, 0xb1, 0x64, 0x31, 0xc7, 0x96, 0xf3, 0xd8, 0x47,
	0x04, 0xae, 0x9c, 0x6b, 0x2f, 0x74, 0x0b, 0x2e, 0x79, 0x82, 0xeb, 0x38, 0x32, 0xc6, 0xe9, 0xc7,
	0xe3, 0xe4, 0x18, 0x6a, 0xac, 0x95, 0x46, 0xf7, 0x31, 0x48, 0x5f, 0x85, 0x8b, 0xfa, 0x38, 0x12,
	0xea, 0x38, 0xf4, 0x5d, 0xfc, 0xd7, 0x65, 0x36, 0x0f, 0xd0, 0xab, 0x70, 0xc1, 0xf8, 0x8c, 0x23,
	0x5d, 0xb4, 0x9a, 0x1a, 0xab, 0x9b, 0x65, 0xdf, 0xa5, 0x2f, 0xc1, 0x1a, 0xce, 0xb9, 0xd9, 0xa9,
	0xe2, 0xce, 0x05, 0x5c, 0xf7, 0x5d, 0x7b, 0x02, 0x9b, 0x85, 0x7e, 0x43, 0x3f, 0x82, 0x5a, 0x32,
	0x0d, 0xe4, 0x05, 0x2c, 0x94, 0x25, 0x1c, 0xf6, 0x03, 0xb0, 0x8b, 0x7d, 0xe4, 0xbf, 0x2d, 0xf9,
	0x0d, 0x81, 0xf6, 0xd3, 0xcc, 0x62, 0xd5, 0xd6, 0xbf, 0x06, 0x30, 0x4b, 0x93, 0x49, 0xef, 0x2b,
	0xec, 0x62, 0x1a, 0xe9, 0x3f, 0x5f, 0xef, 0x7f, 0x24, 0xb0, 0xb5, 0x92, 0x71, 0xac, 0xaa, 0xf1,
	0x75, 0x68, 0xcc, 0x35, 0x2a, 0xbc, 0x7b, 0x15, 0x06, 0x99, 0x48, 0xf5, 0x5c, 0x2a, 0xef, 0x01,
	0x3d, 0x10, 0x43, 0xa9, 0x64, 0x18, 0x18, 0xcf, 0xd8, 0xc7, 0xf7, 0x3a, 0x7d, 0x1f, 0x6a, 0xc6,
	0x49, 0x14, 0x5e, 0xfb, 0xc6, 0xce, 0xf6, 0xaa, 0xc6, 0xc4, 0x12, 0x98, 0xfd, 0x3d, 0x81, 0x8d,
	0x3c, 0x6d, 0x66, 0x43, 0x37, 0xe1, 0x6a, 0x10, 0x8f, 0x11, 0xeb, 0x9c, 0x08, 0xd4, 0x14, 0x4f,
	0x5c, 0xae, 0xb1, 0x94, 0x11, 0xb6, 0x11, 0xc4, 0x63, 0x83, 0xf8, 0x14, 0x37, 0x3f, 0x49, 0xf6,
	0xe8, 0x36, 0xac, 0x1b, 0x98, 0xcf, 0x4f, 0x45, 0xa4, 0x9c, 0x51, 0x14, 0x9e, 0x04, 0x78, 0x48,
	0x35, 0x76, 0x29, 0x88, 0xc7, 0x87, 0x18, 0xfe, 0xd0, 0x44, 0xe9, 0x26, 0x34, 0xa5, 0x72, 0x3c,
	0x63, 0x4c, 0xf2, 0x4b, 0x91, 0x34, 0x62, 0x8d, 0x35, 0xa4, 0xba, 0x33, 0x0b, 0xd9, 0x0a, 0x2e,
	0x9b, 0x5c, 0x19, 0x8c, 0x32, 0x59, 0x1d, 0xf8, 0xff, 0x4c, 0x96, 0x72, 0xb8, 0xd6, 0x62, 0x3c,
	0xd1, 0xc2, 0x45, 0x49, 0x15, 0xf6, 0xbf, 0x54, 0x92, 0xda, 0x9d, 0x6d, 0xd0, 0x1b, 0xb0, 0x91,
	0xd3, 0x33, 0x07, 0x24, 0x17, 0x87, 0x66, 0x9a, 0x32, 0x84, 0xfd, 0x4b, 0x19, 0x5e, 0xce, 0x77,
	0xe4, 0x76, 0xa0, 0xc4, 0x78, 0xe0, 0xcf, 0x1a, 0xde, 0x83, 0x1a, 0x16, 0x4f, 0x1b, 0xbe, 0x53,
	0x3c, 0x10, 0xcb, 0x67, 0xc6, 0x12, 0x02, 0xd3, 0x80, 0x5c, 0x77, 0x55, 0x6a, 0x51, 0x0d, 0x9d,
	0xf5, 0x54, 0xd1, 0xcf, 0xa0, 0x85, 0x29, 0xd9, 0xfb, 0xa7, 0x82, 0x45, 0xdf, 0x7d, 0x96, 0xa2,
	0xf3, 0x57, 0x90, 0xce, 0x9f, 0xef, 0xe7, 0xb0, 0x3e, 0x4a, 0x7a, 0x3b, 0x67, 0x4f, 0x3e, 0x3f,
	0xba, 0x45, 0xec, 0x4b, 0x67, 0xc2, 0x2e, 0x8f, 0x16, 0x03, 0x7b, 0xdd, 0xc7, 0x67, 0x56, 0xe9,
	0xb7, 0x33, 0xab, 0xf4, 0xe4, 0xcc, 0x22, 0x5f, 0x4d, 0x2d, 0xf2, 0xf3, 0xd4, 0x22, 0xbf, 0x4e,
	0x2d, 0xf2, 0x78, 0x6a, 0x91, 0xdf, 0xa7, 0x16, 0xf9, 0x73, 0x6a, 0x95, 0x9e, 0x4c, 0x2d, 0xf2,
	0xe8, 0x0f, 0xab, 0xf4, 0x37, 0x21, 0x83, 0x3a, 0x7e, 0x9e, 0xbe, 0xf3, 0x4f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x24, 0xcf, 0x20, 0x80, 0xe3, 0x0a, 0x00, 0x00,
}
